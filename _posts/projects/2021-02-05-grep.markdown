---
layout: front
title: "Greplike"
header: "/assets/img/project/grep/grepping.png"
cover: "/assets/img/project/grep/grep.png"
cover-active: "/assets/img/project/grep/grep.gif"
tags: project 

---


<h3>In Progress... </h3>
---

<h2 align="center">A pattern-matching file parser and regular expression engine</h2>
<h3>Weapon of choice:</h3>
<p>C</p>
<h3>Adapted from:</h3>
Greplike is an extension of <a href="https://www.oreilly.com/library/view/beautiful-code/9780596510046/ch01.html">Pike's regular expression matcher </a> and is, thus, also inspired by <a href="https://swtch.com/~rsc/regexp/">Russ Cox's series on regular expressions</a>.
<h3>Summary:</h3>

*Greplike* is a rudimentary, toy, pattern-matching tool that can be used, *like grep*, for parsing through files to find occurances of a string using literals or a regular expression. Unlike the *grep* tool, *greplike*
has some limitations including a lesser number of command-line and engine options available. For example: the user cannot invert the search using `-v` or ignore case using `-y` 
(greplike is **always** case-sensitive), and the user may not select a set of regular expressions to use (with *grep* this can be done with the `-p` and `-e` flags for PCRE and extended sets).
Greplike uses a sub-set of [POSIX Basic Regular Expressions](https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions) which does not (currently\*<sub>1</sub>) support the following
meta-characters:

- `{` and `}` (braces) used for matching a preceeding character/group/class *n* times.
- `[^` used for matching characters **not** within the suffix class, e.g. `[^abc]` matches everything besides *abc*.
- POSIX class categories (e.g. `[:upper:]` for all uppercase characters). 

Additionally greplike does not support metacharacters inside groups of classes (e.g. `(a+b+c)+d` is not a valid regular expression in greplike).

<h3>A quick, shallow dive into regular expression engines</h3>

If you're uncertain about what a regular expression is, I recommend reading Friedl's *Mastering Regular Expressions*. Essentially there are two viable ways of parsing and matching a text buffer
using regular expressions. Non-deterministic finite automata (NFA)-based matchers (regex enginers) rely heavily on *backtracking*\*<sub>2</sub> 

<h3>Appendix:</h3>
\*<sub>1</sub> | I, currently, have no plans to keep *greplike* up-to-date and implement upon the documented functionality. As stated, *greplike* was an exercise in learning about string parsing, regular 
expressions, and finite automata.

\*<sub>2</sub> | Backtracking is, essentially, a quality that arises in certain types of algorithmic problems such as constraint statisfaction problems (e.g. a sudoku solver) in which a successful
approach is based upon a condition that can sometimes be partially valid (e.g. Friedl presents the expression `to(nite|knight|night)` as an example, where testing and removing two of the three 
invalid options is required). A backtracked approach requires a variable to be stored (in this case the regular expression string) that can be reverted-to in a scenario where a partial match
eventually results in being invalid (e.g. `tonighz` will not match `to(nite|knight|night)` until the very last character check).
