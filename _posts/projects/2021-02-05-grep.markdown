---
layout: front
title: "Greplike"
cover: /assets/img/project/grep.jpg
tags: project

---

<img style="padding-left:35%;height:25%;width:25%;" src='/assets/img/project/grep.jpg'>

---

<h2 align="center">A regular expression engine and string-matching tool</h2>
<a href="https://github.com/gerlofs/greplike">Source</a>
<h3>Written in:</h3>
C
<h3>Adapted from:</h3>
Greplike is an extension of <a href="https://www.oreilly.com/library/view/beautiful-code/9780596510046/ch01.html">Pike's regular expression matcher </a> and is, thus, also inspired by <a href="https://swtch.com/~rsc/regexp/">Russ Cox's series on regular expressions</a>.
<h3>Summary:</h3>

*Greplike* is the first project in a series surrounding compiler design. Compilers use a lexical analysis step - see: [Mongensen's introduction](https://www.amazon.co.uk/Introduction-Compiler-Undergraduate-Computer-Science/dp/3319669656)
for more information - which requires a regular expression engine to parse plain-text to tokens. In order to correctly write this component, knowledge of regular expressions and pattern matching is required. *Greplike* is a black-box
re-write of the *grep* tool using concepts outlined by Pike and Kernighan in [The Practice of Programming](https://www.amazon.co.uk/Practice-Programming-Professional-Computing/dp/020161586X). The tool is a somewhat-less-efficient\*<sub>2</sub>, 
non-finite-automata version of grep, that builds upon Pike's initial sub-100 sloc engine whilst applying many of the improvements outlined in the subsequent discussion by Kernighan (linked to in the *Adapted From* section).

*Greplike* is a rudimentary, toy, pattern-matching tool that can be used, *like grep*, for parsing through files to find occurances of a string using literals or a regular expression. Unlike the *grep* tool, *greplike*
has some limitations including a lesser number of command-line and engine options available. For example: the user cannot invert the search using `-v` or ignore case using `-y` 
(greplike is **always** case-sensitive), and the user may not select a set of regular expressions to use (with *grep* this can be done with the `-p` and `-e` flags for PCRE and extended sets).
Greplike uses a sub-set of [POSIX Basic Regular Expressions](https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions) which does not (currently\*<sub>1</sub>) support the following
meta-characters:

- `{` and `}` (braces) used for matching a preceeding character/group/class *n* times.
- `[^` used for matching characters **not** within the suffix class, e.g. `[^abc]` matches everything besides *abc*.
- POSIX class categories (e.g. `[:upper:]` for all uppercase characters). 

Additionally greplike does not support metacharacters inside groups of classes (e.g. `(a+b+c)+d` is not a valid regular expression in greplike).

<h3>Using the tool:</h3>

There are a limited number of options available in *greplike*:

> **-f**: Define a list of files to parse.

> **-e**: Define a regular expression to serve as a matching set.

> **-n**: Print the line number of each successful match.

> **-i**: Print the filename of the file in which a match was found.

> **-c**: Count and subsequently print the number of matching occurences. 

Example:

> *General case:*

> `./greplike <expression> <filename>`

> *Match with line numbers:*

> `./greplike -f <filename> -e <expression> -n` 

<h3>Testing:</h3>

Bash scripts are located in the */tests/* folder, there are five test cases\*<sub>3</sub>: 

1. Valid tests: A set of valid expressions are run against a single file full of randomised text (ASCII only).
2. Invalid tests: A set of invalid expressions are run against the above file, all should fail with a return code != 0.
3. Single-file test: A set of files and expressions are used as greplike arguments, for each the return code should be 0.
4. Multi-file test: A set of expressions are run against all three files (dummy*n*.txt), each should return code 0.
5. Timing test: The above test is run using grep and greplike, the times are returned. 

<h3>Appendix:</h3>
\*<sub>1</sub> | I, currently, have no plans to keep *greplike* up-to-date and implement upon the documented functionality. As stated, *greplike* was an exercise in learning about string parsing, and
regular expressions. There will be an finite-automata-centric version which is required for the lexical parsing stage of a compiler. 

\*<sub>2</sub> | I say this because, as Cox discusses, expression matching parsers *can* be horrifically inefficient in certain edge cases due to backtracking. Backtracking is, essentially, 
a quality that arises in certain types of algorithmic problems such as constraint statisfaction problems (e.g. a sudoku solver) in which a successful
approach is based upon a condition that can sometimes be partially valid (e.g. [Friedl](https://www.amazon.co.uk/Mastering-Regular-Expressions-Powerful-Techniques/dp/1565922573)
 presents the expression `to(nite|knight|night)` as an example, where testing and removing two of the three 
invalid options is required). A backtracked approach requires a variable to be stored (in this case the regular expression string) that can be reverted-to in a scenario where a partial match
eventually results in being invalid (e.g. `tonighz` will not match `to(nite|knight|night)` until the very last character check).

\*<sub>3</sub> | I have plans to flesh out this testing to include checks for number of matches and possibly shift this over to python or some other language to write a test harness, this
isn't a priority though.
