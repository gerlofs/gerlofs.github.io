<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2021-03-08T22:54:04+00:00</updated><id>/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Greplike</title><link href="/2021/02/05/grep.html" rel="alternate" type="text/html" title="Greplike" /><published>2021-02-05T00:00:00+00:00</published><updated>2021-02-05T00:00:00+00:00</updated><id>/2021/02/05/grep</id><content type="html" xml:base="/2021/02/05/grep.html">&lt;h3&gt;In Progress... &lt;/h3&gt;
&lt;hr /&gt;

&lt;h2 align=&quot;center&quot;&gt;A pattern-matching file parser and regular expression engine&lt;/h2&gt;
&lt;h3&gt;Weapon of choice:&lt;/h3&gt;
&lt;p&gt;C&lt;/p&gt;
&lt;h3&gt;Adapted from:&lt;/h3&gt;
&lt;p&gt;Greplike is an extension of &lt;a href=&quot;https://www.oreilly.com/library/view/beautiful-code/9780596510046/ch01.html&quot;&gt;Pike’s regular expression matcher &lt;/a&gt; and is, thus, also inspired by &lt;a href=&quot;https://swtch.com/~rsc/regexp/&quot;&gt;Russ Cox’s series on regular expressions&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;Summary:&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Greplike&lt;/em&gt; is a rudimentary, toy, pattern-matching tool that can be used, &lt;em&gt;like grep&lt;/em&gt;, for parsing through files to find occurances of a string using literals or a regular expression. Unlike the &lt;em&gt;grep&lt;/em&gt; tool, &lt;em&gt;greplike&lt;/em&gt;
has some limitations including a lesser number of command-line and engine options available. For example: the user cannot invert the search using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-v&lt;/code&gt; or ignore case using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-y&lt;/code&gt; 
(greplike is &lt;strong&gt;always&lt;/strong&gt; case-sensitive), and the user may not select a set of regular expressions to use (with &lt;em&gt;grep&lt;/em&gt; this can be done with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-p&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-e&lt;/code&gt; flags for PCRE and extended sets).
Greplike uses a sub-set of &lt;a href=&quot;https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions&quot;&gt;POSIX Basic Regular Expressions&lt;/a&gt; which does not (currently*&lt;sub&gt;1&lt;/sub&gt;) support the following
meta-characters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;}&lt;/code&gt; (braces) used for matching a preceeding character/group/class &lt;em&gt;n&lt;/em&gt; times.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[^&lt;/code&gt; used for matching characters &lt;strong&gt;not&lt;/strong&gt; within the suffix class, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[^abc]&lt;/code&gt; matches everything besides &lt;em&gt;abc&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;POSIX class categories (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[:upper:]&lt;/code&gt; for all uppercase characters).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally greplike does not support metacharacters inside groups of classes (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a+b+c)+d&lt;/code&gt; is not a valid regular expression in greplike).&lt;/p&gt;

&lt;h3&gt;A quick, shallow dive into regular expression engines&lt;/h3&gt;

&lt;p&gt;If you’re uncertain about what a regular expression is, I recommend reading Friedl’s &lt;em&gt;Mastering Regular Expressions&lt;/em&gt;. Essentially there are two viable ways of parsing and matching a text buffer
using regular expressions. Non-deterministic finite automata (NFA)-based matchers (regex enginers) rely heavily on &lt;em&gt;backtracking&lt;/em&gt;*&lt;sub&gt;2&lt;/sub&gt;&lt;/p&gt;

&lt;h3&gt;Appendix:&lt;/h3&gt;
&lt;p&gt;*&lt;sub&gt;1&lt;/sub&gt; | I, currently, have no plans to keep &lt;em&gt;greplike&lt;/em&gt; up-to-date and implement upon the documented functionality. As stated, &lt;em&gt;greplike&lt;/em&gt; was an exercise in learning about string parsing, regular 
expressions, and finite automata.&lt;/p&gt;

&lt;p&gt;*&lt;sub&gt;2&lt;/sub&gt; | Backtracking is, essentially, a quality that arises in certain types of algorithmic problems such as constraint statisfaction problems (e.g. a sudoku solver) in which a successful
approach is based upon a condition that can sometimes be partially valid (e.g. Friedl presents the expression &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to(nite|knight|night)&lt;/code&gt; as an example, where testing and removing two of the three 
invalid options is required). A backtracked approach requires a variable to be stored (in this case the regular expression string) that can be reverted-to in a scenario where a partial match
eventually results in being invalid (e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tonighz&lt;/code&gt; will not match &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to(nite|knight|night)&lt;/code&gt; until the very last character check).&lt;/p&gt;</content><author><name></name></author><category term="project" /><summary type="html">In Progress...</summary></entry></feed>