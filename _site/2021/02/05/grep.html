<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Greplike</title>
		<link rel="shorcut icon" type="image/png" href="/assets/img/icon.png">
		<link rel="stylesheet" href="/assets/css/styles.css">
	</head>
	<body>
		<div class="wrapper">
		<div class="side-div">
			<div class="nav-wrapper">
				<a class="avatar" href="/"><img src="https://avatars.githubusercontent.com/u/77435397?"></img></a>
				<nav class="links">
	<a href="/about/">About</a>
	<a href="/posts/">Blog</a>
	<a href="/projects/">Projects</a>
</nav>

			</div>
		</div>
		<div class="centre-div">
			<section>
				<h3>In Progress... </h3>
<hr />

<h2 align="center">A pattern-matching file parser and regular expression engine</h2>
<h3>Weapon of choice:</h3>
<p>C</p>
<h3>Adapted from:</h3>
<p>Greplike is an extension of <a href="https://www.oreilly.com/library/view/beautiful-code/9780596510046/ch01.html">Pike’s regular expression matcher </a> and is, thus, also inspired by <a href="https://swtch.com/~rsc/regexp/">Russ Cox’s series on regular expressions</a>.</p>
<h3>Summary:</h3>

<p><em>Greplike</em> is a rudimentary, toy, pattern-matching tool that can be used, <em>like grep</em>, for parsing through files to find occurances of a string using literals or a regular expression. Unlike the <em>grep</em> tool, <em>greplike</em>
has some limitations including a lesser number of command-line and engine options available. For example: the user cannot invert the search using <code class="language-plaintext highlighter-rouge">-v</code> or ignore case using <code class="language-plaintext highlighter-rouge">-y</code> 
(greplike is <strong>always</strong> case-sensitive), and the user may not select a set of regular expressions to use (with <em>grep</em> this can be done with the <code class="language-plaintext highlighter-rouge">-p</code> and <code class="language-plaintext highlighter-rouge">-e</code> flags for PCRE and extended sets).
Greplike uses a sub-set of <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions">POSIX Basic Regular Expressions</a> which does not (currently*<sub>1</sub>) support the following
meta-characters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">{</code> and <code class="language-plaintext highlighter-rouge">}</code> (braces) used for matching a preceeding character/group/class <em>n</em> times.</li>
  <li><code class="language-plaintext highlighter-rouge">[^</code> used for matching characters <strong>not</strong> within the suffix class, e.g. <code class="language-plaintext highlighter-rouge">[^abc]</code> matches everything besides <em>abc</em>.</li>
  <li>POSIX class categories (e.g. <code class="language-plaintext highlighter-rouge">[:upper:]</code> for all uppercase characters).</li>
</ul>

<p>Additionally greplike does not support metacharacters inside groups of classes (e.g. <code class="language-plaintext highlighter-rouge">(a+b+c)+d</code> is not a valid regular expression in greplike).</p>

<h3>A quick, shallow dive into regular expression engines</h3>

<p>If you’re uncertain about what a regular expression is, I recommend reading Friedl’s <em>Mastering Regular Expressions</em>. Essentially there are two viable ways of parsing and matching a text buffer
using regular expressions. Non-deterministic finite automata (NFA)-based matchers (regex enginers) rely heavily on <em>backtracking</em>*<sub>2</sub></p>

<h3>Appendix:</h3>
<p>*<sub>1</sub> | I, currently, have no plans to keep <em>greplike</em> up-to-date and implement upon the documented functionality. As stated, <em>greplike</em> was an exercise in learning about string parsing, regular 
expressions, and finite automata.</p>

<p>*<sub>2</sub> | Backtracking is, essentially, a quality that arises in certain types of algorithmic problems such as constraint statisfaction problems (e.g. a sudoku solver) in which a successful
approach is based upon a condition that can sometimes be partially valid (e.g. Friedl presents the expression <code class="language-plaintext highlighter-rouge">to(nite|knight|night)</code> as an example, where testing and removing two of the three 
invalid options is required). A backtracked approach requires a variable to be stored (in this case the regular expression string) that can be reverted-to in a scenario where a partial match
eventually results in being invalid (e.g. <code class="language-plaintext highlighter-rouge">tonighz</code> will not match <code class="language-plaintext highlighter-rouge">to(nite|knight|night)</code> until the very last character check).</p>
 
			</section>
		</div>
		</div>
	</body>
	<footer>
		<div class="foot-wrapper">
	<div class="foot-icons">
		<a href="https://github.com/gerlofs"><img src="/assets/img/GitHub-Mark-32px.png"></img></a>
		<a href="https://fosstodon.org/@gerlofs"><img src="/assets/img/Mastodon.png" style="height:32px;width:32px";></img></a>
	</div>
	<div class="foot-pledge">
		<p> This site was built with <a href="https://jekyllrb.com">Jekyll</a></p>
		<p style="color: black;"> Icon taken from <a style="color: black;" href="https://www.flaticon.com/free-icon/pigeon_1196600">here...</a></p>
	</div>
</div>

	</footer>
