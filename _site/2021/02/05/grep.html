<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Greplike</title>
		<link rel="shorcut icon" type="image/png" href="/assets/img/icon.png">
		<link rel="stylesheet" href="/assets/css/styles.css">
	</head>
	<body>
		<div class="wrapper">
		<div class="side-div">
			<div class="nav-wrapper">
				<a class="avatar" href="/"><img src="https://avatars.githubusercontent.com/u/77435397?"></img></a>
				<nav class="links">
	<a href="/about/">About</a>
	<a href="/posts/">Blog</a>
	<a href="/projects/">Projects</a>
</nav>

			</div>
		</div>
		<div class="centre-div">
			<section>
				<p><img style="padding-left:35%;height:25%;width:25%;" src="/assets/img/project/grep.jpg" /></p>

<hr />

<h2 align="center">A regular expression engine and string-matching tool</h2>
<p><a href="https://github.com/gerlofs/greplike">Source</a></p>
<h3>Written in:</h3>
<p>C</p>
<h3>Adapted from:</h3>
<p>Greplike is an extension of <a href="https://www.oreilly.com/library/view/beautiful-code/9780596510046/ch01.html">Pike’s regular expression matcher </a> and is, thus, also inspired by <a href="https://swtch.com/~rsc/regexp/">Russ Cox’s series on regular expressions</a>.</p>
<h3>Summary:</h3>

<p><em>Greplike</em> is the first project in a series surrounding compiler design. Compilers use a lexical analysis step - see: <a href="https://www.amazon.co.uk/Introduction-Compiler-Undergraduate-Computer-Science/dp/3319669656">Mongensen’s introduction</a>
for more information - which requires a regular expression engine to parse plain-text to tokens. In order to correctly write this component, knowledge of regular expressions and pattern matching is required. <em>Greplike</em> is a black-box
re-write of the <em>grep</em> tool using concepts outlined by Pike and Kernighan in <a href="https://www.amazon.co.uk/Practice-Programming-Professional-Computing/dp/020161586X">The Practice of Programming</a>. The tool is a somewhat-less-efficient*<sub>2</sub>, 
non-finite-automata version of grep, that builds upon Pike’s initial sub-100 sloc engine whilst applying many of the improvements outlined in the subsequent discussion by Kernighan (linked to in the <em>Adapted From</em> section).</p>

<p><em>Greplike</em> is a rudimentary, toy, pattern-matching tool that can be used, <em>like grep</em>, for parsing through files to find occurances of a string using literals or a regular expression. Unlike the <em>grep</em> tool, <em>greplike</em>
has some limitations including a lesser number of command-line and engine options available. For example: the user cannot invert the search using <code class="language-plaintext highlighter-rouge">-v</code> or ignore case using <code class="language-plaintext highlighter-rouge">-y</code> 
(greplike is <strong>always</strong> case-sensitive), and the user may not select a set of regular expressions to use (with <em>grep</em> this can be done with the <code class="language-plaintext highlighter-rouge">-p</code> and <code class="language-plaintext highlighter-rouge">-e</code> flags for PCRE and extended sets).
Greplike uses a sub-set of <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Basic_Regular_Expressions">POSIX Basic Regular Expressions</a> which does not (currently*<sub>1</sub>) support the following
meta-characters:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">{</code> and <code class="language-plaintext highlighter-rouge">}</code> (braces) used for matching a preceeding character/group/class <em>n</em> times.</li>
  <li><code class="language-plaintext highlighter-rouge">[^</code> used for matching characters <strong>not</strong> within the suffix class, e.g. <code class="language-plaintext highlighter-rouge">[^abc]</code> matches everything besides <em>abc</em>.</li>
  <li>POSIX class categories (e.g. <code class="language-plaintext highlighter-rouge">[:upper:]</code> for all uppercase characters).</li>
</ul>

<p>Additionally greplike does not support metacharacters inside groups of classes (e.g. <code class="language-plaintext highlighter-rouge">(a+b+c)+d</code> is not a valid regular expression in greplike).</p>

<h3>Using the tool:</h3>

<p>There are a limited number of options available in <em>greplike</em>:</p>

<blockquote>
  <p><strong>-f</strong>: Define a list of files to parse.</p>
</blockquote>

<blockquote>
  <p><strong>-e</strong>: Define a regular expression to serve as a matching set.</p>
</blockquote>

<blockquote>
  <p><strong>-n</strong>: Print the line number of each successful match.</p>
</blockquote>

<blockquote>
  <p><strong>-i</strong>: Print the filename of the file in which a match was found.</p>
</blockquote>

<blockquote>
  <p><strong>-c</strong>: Count and subsequently print the number of matching occurences.</p>
</blockquote>

<p>Example:</p>

<blockquote>
  <p><em>General case:</em></p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">./greplike &lt;expression&gt; &lt;filename&gt;</code></p>
</blockquote>

<blockquote>
  <p><em>Match with line numbers:</em></p>
</blockquote>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">./greplike -f &lt;filename&gt; -e &lt;expression&gt; -n</code></p>
</blockquote>

<h3>Testing:</h3>

<p>Bash scripts are located in the <em>/tests/</em> folder, there are five test cases*<sub>3</sub>:</p>

<ol>
  <li>Valid tests: A set of valid expressions are run against a single file full of randomised text (ASCII only).</li>
  <li>Invalid tests: A set of invalid expressions are run against the above file, all should fail with a return code != 0.</li>
  <li>Single-file test: A set of files and expressions are used as greplike arguments, for each the return code should be 0.</li>
  <li>Multi-file test: A set of expressions are run against all three files (dummy<em>n</em>.txt), each should return code 0.</li>
  <li>Timing test: The above test is run using grep and greplike, the times are returned.</li>
</ol>

<h3>Appendix:</h3>
<p>*<sub>1</sub> | I, currently, have no plans to keep <em>greplike</em> up-to-date and implement upon the documented functionality. As stated, <em>greplike</em> was an exercise in learning about string parsing, and
regular expressions. There will be an finite-automata-centric version which is required for the lexical parsing stage of a compiler.</p>

<p>*<sub>2</sub> | I say this because, as Cox discusses, expression matching parsers <em>can</em> be horrifically inefficient in certain edge cases due to backtracking. Backtracking is, essentially, 
a quality that arises in certain types of algorithmic problems such as constraint statisfaction problems (e.g. a sudoku solver) in which a successful
approach is based upon a condition that can sometimes be partially valid (e.g. <a href="https://www.amazon.co.uk/Mastering-Regular-Expressions-Powerful-Techniques/dp/1565922573">Friedl</a>
 presents the expression <code class="language-plaintext highlighter-rouge">to(nite|knight|night)</code> as an example, where testing and removing two of the three 
invalid options is required). A backtracked approach requires a variable to be stored (in this case the regular expression string) that can be reverted-to in a scenario where a partial match
eventually results in being invalid (e.g. <code class="language-plaintext highlighter-rouge">tonighz</code> will not match <code class="language-plaintext highlighter-rouge">to(nite|knight|night)</code> until the very last character check).</p>

<p>*<sub>3</sub> | I have plans to flesh out this testing to include checks for number of matches and possibly shift this over to python or some other language to write a test harness, this
isn’t a priority though.</p>
 
			</section>
		</div>
		</div>
	</body>
	<footer>
		<div class="foot-wrapper">
	<div class="foot-icons">
		<a href="https://github.com/gerlofs"><img src="/assets/img/GitHub-Mark-32px.png"></img></a>
		<a href="https://fosstodon.org/@gerlofs"><img src="/assets/img/Mastodon.png" style="height:32px;width:32px";></img></a>
	</div>
	<div class="foot-pledge">
		<p> This site was built with <a href="https://jekyllrb.com">Jekyll</a></p>
		<p style="color: black;"> Icon taken from <a style="color: black;" href="https://www.flaticon.com/free-icon/pigeon_1196600">here...</a></p>
	</div>
</div>

	</footer>
